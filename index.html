<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="418project : Website for 15418 final project">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>418project</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/abutko/418project">View on GitHub</a>

          <h1 id="project_title">418 project: Parallel Hash Tables</h1>
          <h2 id="project_tagline">Website for 15418 final project</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/abutko/project418/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/abutko/project418/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parallel Hash Tables - Final Report</h3>

<a href = "proposal.html">Proposal </a><br>

<a href = "checkpoint.html">Checkpoint Report </a>

<p><strong>TITLE.</strong> Parallel Hash Tables. Brought to you by Manu Garg, Andrew Butko.</p>

<p><strong>SUMMARY.</strong> We implemented concurrent hash tables that use coarse grained/fine grained locks. We also implemented
a lock-free version of hash tables. Given the speedup of our implementations we demonstrate that lock-free is faster than fine-grained
which in turn is faster than coarse-grained in most scenarios.</p>

<p><strong>BACKGROUND.</strong> A hashtable is a datastructure that maps keys to values and allows fast accesses to the data.  
More on hash tables: <a href="https://en.wikipedia.org/wiki/Hash_table">hash tables</a>. The operations on a hashtable include 
searching a key, inserting a key, value pair and deleting a key from the table. We implemented the hashtable with separate chaining 
i.e. a linked list per bucket (Fig.1)

<figure>
  <img src="hashtable.png" alt="hash table">
  <figcaption> Fig.1 - Hashtable with separate chaining</figcaption>
</figure>

Although none of the individual operations are computationaly expensive (roughly O(1) average access time per op for a good hash table 
implementation), they are highly parallelizable, especially when contention isn't high because at that point the different operations
are accessing different buckets.
</p>

<p>
<table class="projectSchedule">
<tr>
  <td width="110"><span style="font-weight: bold;">Week</span></td>
  <td width="380"><span style="font-weight: bold;">Goals</span></td>
  <td width="380"><span style="font-weight: bold;">Assigned To</span></td>
  <td width="380"><span style="font-weight: bold;">Completed?</span></td>

</tr>
<tr>
  <td>April 3-9</td>
  <td>Read listed papers and research RMC model. Plan interface and testing suite. </td>
  <td>Andrew/Manu</td>
  <td>Yes</td>
</tr>

<tr>
  <td>April 10-16</td>
  <td>
    Implement fine and coarse locking schemes.
  </td>
  <td>Andrew/Manu</td>
  <td>Yes</td>
</tr>

<tr>
  <td>April 17-20</td>
  <td>
    Test various parameters on completed implementations, start to compile testing results.
  </td>
  <td>Manu</td>
  <td></td>
</tr>
<tr>
  <td>April 20-23</td>
  <td>
    Re-read paper on lock-free version and start to code.
  </td>
  <td>Andrew</td>
  <td></td>
</tr>
<tr>
  <td>April 24-27</td>
  <td>
    Finish coding lock-free implementation and performance analysis.
  </td>
  <td>Andrew/Manu</td>
  <td></td>
</tr>
  <td>April 27-30</td>
  <td>
    Buffer days.
  </td>
  <td>Andrew/Manu</td>
  <td></td>
</tr>

<tr>
  <td>May 1-4</td>
  <td>
    BDD if we are ahead. Begin to compile final report.
  </td>
  <td>Andrew/Manu</td>
  <td></td>
</tr>

<tr>
  <td>May 5-8</td>
  <td>
    Final buffer days, complete final report.
  </td>
  <td>Andrew/Manu</td>
  <td></td>
</tr>
</table>
</p>

<p><strong>WORK COMPLETED.</strong> 
We have completed the implementation of fine and coarse grain locking schemes 
(these are available in this repository under the code/ directory). Coarse-grain is implemented with a single pthread reader-writer lock 
on the table while fine-grain adds mutex locks for each bucket in the hash table. We also designed a testing suite that
allows us to vary parameters such as workload size, operation distribution, and the range of keys. This is currently done
pseudo-randomly, and we will explore variations on this in the future. Note - we started with a generic sequential code base
from https://gist.github.com/aozturk/2368896.
</p>
<p><strong>GOALS AND DELIVERABLES.</strong> 
We will definitely be able to complete all deliverables previously mentioned (lock-free implementation, performance analysis).
For the competition we would show performance graphs.
We are on track with our initial goals and don't have anything new to add. We listed BDDs under the "nice to haves"
and have left room in the schedule to work on this if we complete our primary goals on time. We have not researched this thoroughly
and are not sure of the amount of work this will involve, but with the remaining time we have we hopefully will manage to
have some additional features.
</p>

<p><strong>PRELIMINARY RESULTS</strong>
With our testing suite we have seen a performance improvement with the fine-grain locking as expected. We tested this with
std::mutex and pthread reader-writer locks and found mutex locks had better performance. As we just completed the testing harness,
we still need to compile an intial performance report (speedup graphs). This is the first goal listed on the updated 
schedule above.
</p>
  </body>
</html>
